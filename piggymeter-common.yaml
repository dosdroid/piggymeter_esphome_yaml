esp32:
  variant: ${variant}
  board: ${board}
  framework:
    type: esp-idf
  
    
      #esp-idf
  

logger:
  id: 'loggerid'
  logs:
    component: DEBUG
  # component: INFO
   

wifi:
  networks:
      ssid: !secret wifi_ssid
      password: !secret wifi_password
     #optiona in case you have issues with mDNS
     #manual_ip:
    # Set this to the IP of the ESP
        #static_ip: 192.168.1.123
    # Set this to the IP address of the router. Often ends with .1
        #gateway: 192.168.1.1
    # The subnet of the network. 255.255.255.0 works for most home networks.
        #subnet: 255.255.255.0
  # Optional domain
  # domain: .lan
  
api:
  encryption:
    key: !secret encryption_key

ota:
  password: !secret ota_pass



external_components:
    # IEC62056-21 component
  - source: github://aquaticus/esphome-iec62056

globals:
  - id: last_update
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: accumulated_energy
    type: double
    restore_value: yes
    initial_value: '0.0'

uart:
  - id: uart_meter
    rx_pin: ${rx_pin}
    tx_pin: ${tx_pin}
    baud_rate: 300
    data_bits: 7
    parity: EVEN
    stop_bits: 1

switch:
  - platform: gpio
    pin: ${led_pin}
    name: Internal LED
    id: led_switch
    internal: True

  - platform: iec62056
    name: 'Readout Trigger'
    id: 'readout_trigger'

  - platform: restart
    name: "PiggyMeter Restart"

binary_sensor:
  - platform: iec62056
    id: meter_status
    name: Meter Connection Status
    on_press:
      then:
        - switch.turn_on: led_switch
    on_release:
      then:
        - switch.turn_off: led_switch
        

iec62056:
  update_interval: 60s
  baud_rate_max: 9600
   

# Modify the list and OBIS codes if needed
# Doc:  https://aquaticus.info/iec62056.html

sensor:
  - platform: iec62056
    obis: 1.8.0
    name: Absolute active energy total
    id: absolute_active_energy_total
    unit_of_measurement: kWh
    accuracy_decimals: 3
    device_class: energy
    state_class: total_increasing
    on_value:
      then:
        - lambda: |-
            if (fabs(id(absolute_active_energy_total).state - id(accumulated_energy)) > 1.1) { //Update accumulated energy if drift is more than 1.1 kWh
            id(accumulated_energy) = id(absolute_active_energy_total).state;
            id(last_update) = millis();  // Update the last update time
            }
        

  - platform: iec62056
    name: Instantaneous current in phase L1
    id: instantaneous_current_in_phase_l1
    obis: "11.4"
    unit_of_measurement: A
    accuracy_decimals: 3
    device_class: current
    state_class: measurement

  - platform: iec62056
    name: Instantaneous voltage in phase L1
    id: instantaneous_voltage_in_phase_l1
    obis: "12.4"
    unit_of_measurement: V
    accuracy_decimals: 1
    device_class: voltage
    state_class: measurement

  - platform: template
    name: "Instantaneous Power in Phase L1"
    id: instantaneous_power_in_phase_l1
    unit_of_measurement: 'W'
    accuracy_decimals: 4
    lambda: !lambda |-
      return id(instantaneous_voltage_in_phase_l1).state * id(instantaneous_current_in_phase_l1).state;
    update_interval: 10s
  
  - platform: template
    name: "Accumulated Energy Consumption"
    id: accumulated_energy_consumption
    unit_of_measurement: "kWh"
    accuracy_decimals: 3
    device_class: energy  # Important for integration with the energy dashboard
    state_class: total_increasing  # Important for long-term statistics
    lambda: !lambda |-
      if (id(last_update) == 0) {
      id(last_update) = millis();
      return id(accumulated_energy);
      }
      uint32_t now = millis();
      double time_difference = (now - id(last_update)) / 3600000.0; // Convert milliseconds to hours
      double energy = id(instantaneous_power_in_phase_l1).state * time_difference / 1000.0; // Convert power (W) to energy (kWh)
      id(accumulated_energy) += energy;
      return id(accumulated_energy);




  - platform: internal_temperature
    name: "Wemos S2 mini SoC Temperature"
    update_interval: 60s



interval:
  - interval: 30s
    then:
      - sensor.template.publish:
          id: accumulated_energy_consumption
          state: !lambda 'return id(accumulated_energy);'

  - interval: 20s
    then:
      - sensor.template.publish:
          id: instantaneous_power_in_phase_l1
          state: !lambda 'return id(instantaneous_power_in_phase_l1).state;'
